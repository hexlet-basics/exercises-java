Тело цикла, как и тело метода — это место выполнения инструкций. Значит, мы можем использовать внутри него все изученное ранее — в том числе условные конструкции.

Рассмотрим метод, который считает, сколько раз входит буква в предложение:

```java
countChars("Fear cuts deeper than swords.", 'e'); // 4
// Если вы ничего не нашли, то результат — 0 совпадений
countChars("Sansa", 'y'); // 0
```

Сначала попробуйте ответить на вопросы:

* Является ли эта операция агрегацией?
* Какой будет проверка на вхождение символа?

А теперь посмотрим на фрагмент кода:

```java
public static int countChars(String str, char ch) {
  var i = 0;
  var count = 0;
  while (i < str.length()) {
    if (str.charAt(i) == ch) {
      // Считаем только подходящие символы
      count = count + 1;
    }
    // Счетчик увеличивается в любом случае
    i = i + 1;
  }

  return count;
}
```

Эта задача является агрегирующей. Метод считает не все символы, но при этом для подсчета самой суммы все равно приходится анализировать каждый символ.

Ключевое отличие этого цикла от рассмотренных в наличии условия внутри тела. Переменная `count` увеличивается только в том случае, когда текущий рассматриваемый символ совпадает с ожидаемым. В остальном — это типичный агрегатный метод, который возвращает количество нужных символов вызываемому коду.
