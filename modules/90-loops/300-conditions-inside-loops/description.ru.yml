---

name: Условия внутри тела цикла
theory: |

  Тело цикла, как и тело метода — это место выполнения инструкций. Значит, мы можем использовать внутри него всё изученное ранее, например — условные конструкции.

  Представьте себе метод, который считает, сколько раз входит буква в предложение. Пример его работы:

  ```java
  countChars("Fear cuts deeper than swords.", 'e'); // 4
  // Если вы ничего не нашли, то результат — 0 совпадений
  countChars("Sansa", 'y'); // 0
  ```

  Перед тем как посмотреть его содержимое, попробуйте ответить на вопросы:

  * Является ли эта операция агрегацией?
  * Какой будет проверка на вхождение символа?

  ```java
  public static int countChars(String str, char ch) => {
    var i = 0;
    var count = 0;
    while (i < str.length()) {
      if (str.charAt(i) == ch) {
        // Считаем только подходящие символы
        count = count + 1;
      }
      // Счетчик увеличивается в любом случае
      i = i + 1;
    }

    return count;
  };
  ```

  Эта задача является агрегирующей. Несмотря на то, что метод считает не все символы, для подсчета самой суммы все равно приходится анализировать каждый символ.

  Ключевое отличие этого цикла от рассмотренных в наличии условия внутри тела. Переменная `count` увеличивается только в том случае, когда текущий рассматриваемый символ совпадает с ожидаемым.

  В остальном — это типичный агрегатный метод, которая возвращает количество нужных символов вызываемому коду.

instructions: |

  Метод из теории учитывает регистр букв. То есть `A` и `a` с его точки зрения разные символы. Реализуйте вариант этого же метода, так чтобы регистр букв был не важен:

  ```java
  App.countChars("HexlEt", 'e'); // 2
  App.countChars("HexlEt", 'E'); // 2
  ```

  * `Character.toLowerCase()` – переводит символ в нижний регистр

tips: []

